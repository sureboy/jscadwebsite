<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: src/geometries/geom2/toOutlines.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: src/geometries/geom2/toOutlines.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const vec2 = require('../../maths/vec2')

const toSides = require('./toSides')

/*
 * Create a list of edges which SHARE vertices.
 * This allows the edges to be traversed in order.
 */
const toSharedVertices = (sides) => {
  const unique = new Map() // {key: vertex}
  const getUniqueVertex = (vertex) => {
    const key = vertex.toString()
    if (unique.has(key)) {
      return unique.get(key)
    } else {
      unique.set(key, vertex)
      return vertex
    }
  }

  return sides.map((side) => side.map(getUniqueVertex))
}

/*
 * Convert a list of sides into a map from vertex to edges.
 */
const toVertexMap = (sides) => {
  const vertexMap = new Map()
  // first map to edges with shared vertices
  const edges = toSharedVertices(sides)
  // construct adjacent edges map
  edges.forEach((edge) => {
    if (vertexMap.has(edge[0])) {
      vertexMap.get(edge[0]).push(edge)
    } else {
      vertexMap.set(edge[0], [edge])
    }
  })
  return vertexMap
}

/**
 * Create the outline(s) of the given geometry.
 * @param {geom2} geometry - geometry to create outlines from
 * @returns {Array} an array of outlines, where each outline is an array of ordered points
 * @alias module:modeling/geometries/geom2.toOutlines
 *
 * @example
 * let geometry = subtract(rectangle({size: [5, 5]}), rectangle({size: [3, 3]}))
 * let outlines = toOutlines(geometry) // returns two outlines
 */
const toOutlines = (geometry) => {
  const vertexMap = toVertexMap(toSides(geometry)) // {vertex: [edges]}
  const outlines = []
  while (true) {
    let startSide
    for (const [vertex, edges] of vertexMap) {
      startSide = edges.shift()
      if (!startSide) {
        vertexMap.delete(vertex)
        continue
      }
      break
    }
    if (startSide === undefined) break // all starting sides have been visited

    const connectedVertexPoints = []
    const startVertex = startSide[0]
    while (true) {
      connectedVertexPoints.push(startSide[0])
      const nextVertex = startSide[1]
      if (nextVertex === startVertex) break // the outline has been closed
      const nextPossibleSides = vertexMap.get(nextVertex)
      if (!nextPossibleSides) {
        throw new Error(`geometry is not closed at vertex ${nextVertex}`)
      }
      const nextSide = popNextSide(startSide, nextPossibleSides)
      if (nextPossibleSides.length === 0) {
        vertexMap.delete(nextVertex)
      }
      startSide = nextSide
    } // inner loop

    // due to the logic of fromPoints()
    // move the first point to the last
    if (connectedVertexPoints.length > 0) {
      connectedVertexPoints.push(connectedVertexPoints.shift())
    }
    outlines.push(connectedVertexPoints)
  } // outer loop
  vertexMap.clear()
  return outlines
}

// find the first counter-clockwise edge from startSide and pop from nextSides
const popNextSide = (startSide, nextSides) => {
  if (nextSides.length === 1) {
    return nextSides.pop()
  }
  const v0 = vec2.create()
  const startAngle = vec2.angleDegrees(vec2.subtract(v0, startSide[1], startSide[0]))
  let bestAngle
  let bestIndex
  nextSides.forEach((nextSide, index) => {
    const nextAngle = vec2.angleDegrees(vec2.subtract(v0, nextSide[1], nextSide[0]))
    let angle = nextAngle - startAngle
    if (angle &lt; -180) angle += 360
    if (angle >= 180) angle -= 360
    if (bestIndex === undefined || angle > bestAngle) {
      bestIndex = index
      bestAngle = angle
    }
  })
  const nextSide = nextSides[bestIndex]
  nextSides.splice(bestIndex, 1) // remove side from list
  return nextSide
}

module.exports = toOutlines
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-modeling_booleans.html">modeling/booleans</a></li><li><a href="module-modeling_colors.html">modeling/colors</a></li><li><a href="module-modeling_connectors.html">modeling/connectors</a></li><li><a href="module-modeling_curves.html">modeling/curves</a></li><li><a href="module-modeling_curves_bezier.html">modeling/curves/bezier</a></li><li><a href="module-modeling_expansions.html">modeling/expansions</a></li><li><a href="module-modeling_extrusions.html">modeling/extrusions</a></li><li><a href="module-modeling_extrusions_slice.html">modeling/extrusions/slice</a></li><li><a href="module-modeling_geometries.html">modeling/geometries</a></li><li><a href="module-modeling_geometries_geom2.html">modeling/geometries/geom2</a></li><li><a href="module-modeling_geometries_geom3.html">modeling/geometries/geom3</a></li><li><a href="module-modeling_geometries_path2.html">modeling/geometries/path2</a></li><li><a href="module-modeling_geometries_poly2.html">modeling/geometries/poly2</a></li><li><a href="module-modeling_geometries_poly3.html">modeling/geometries/poly3</a></li><li><a href="module-modeling_hulls.html">modeling/hulls</a></li><li><a href="module-modeling_maths.html">modeling/maths</a></li><li><a href="module-modeling_maths_line2.html">modeling/maths/line2</a></li><li><a href="module-modeling_maths_line3.html">modeling/maths/line3</a></li><li><a href="module-modeling_maths_mat4.html">modeling/maths/mat4</a></li><li><a href="module-modeling_maths_plane.html">modeling/maths/plane</a></li><li><a href="module-modeling_maths_utils.html">modeling/maths/utils</a></li><li><a href="module-modeling_maths_vec2.html">modeling/maths/vec2</a></li><li><a href="module-modeling_maths_vec3.html">modeling/maths/vec3</a></li><li><a href="module-modeling_maths_vec4.html">modeling/maths/vec4</a></li><li><a href="module-modeling_measurements.html">modeling/measurements</a></li><li><a href="module-modeling_modifiers.html">modeling/modifiers</a></li><li><a href="module-modeling_primitives.html">modeling/primitives</a></li><li><a href="module-modeling_text.html">modeling/text</a></li><li><a href="module-modeling_transforms.html">modeling/transforms</a></li><li><a href="module-modeling_utils.html">modeling/utils</a></li></ul><h3>Global</h3><ul><li><a href="global.html#TAU">TAU</a></li><li><a href="global.html#comparePoints">comparePoints</a></li><li><a href="global.html#comparePolygons">comparePolygons</a></li><li><a href="global.html#comparePolygonsAsPoints">comparePolygonsAsPoints</a></li><li><a href="global.html#compareVectors">compareVectors</a></li><li><a href="global.html#distanceBetween">distanceBetween</a></li><li><a href="global.html#lengths">lengths</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat Jan 25 2025 09:49:34 GMT+0800 (中国标准时间)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
